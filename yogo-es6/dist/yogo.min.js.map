{"version":3,"names":[],"mappings":"","sources":["yogo.min.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar yogo=require(\"../util\");\n\n\nclass NodeTraverser {\n\n\ttraverseNodes(nodeCallback, variationCallback,\n\t\t\tvariationCompleteCallback) {\n\n\t\tvar nodes = this.nodes;\n\t\tfor (var ni = 0; ni < nodes.length; ni++) {\n\t\t\tvar node = nodes[ni];\n\t\t\tif (nodeCallback) {\n\t\t\t\tvar ncr = nodeCallback.call(node, node);\n\t\t\t\tif (ncr === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar variations = node.variations;\n\t\t\tif (!variations) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (var vi = 0; vi < variations.length; vi++) {\n\t\t\t\tvar variation = variations[vi];\n\t\t\t\tif (variationCallback) {\n\t\t\t\t\tvar vcr = variationCallback.call(variation, variation);\n\t\t\t\t\tif (vcr === false) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvariation.traverseNodes(nodeCallback, variationCallback,\n\t\t\t\t\t\tvariationCompleteCallback);\n\t\t\t\tif (variationCompleteCallback) {\n\t\t\t\t\tvar vcr = variationCompleteCallback.call(variation,\n\t\t\t\t\t\t\tvariation);\n\t\t\t\t\tif (vcr === false) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tselectNodes(predicate) {\n\t\tvar nodes = [];\n\t\tthis.traverseNodes(function(node) {\n\t\t\tif (predicate.call(node, node)) {\n\t\t\t\tnodes.push(node);\n\t\t\t}\n\t\t});\n\t\treturn nodes;\n\t}\n\n\tfindNode(predicate) {\n\t\tvar found = [];\n\t\tthis.traverseNodes(function(node) {\n\t\t\tvar result = predicate.call(node, node);\n\t\t\tif (result === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (result === true) {\n\t\t\t\tfound.push(node);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\treturn found[0] || null;\n\t}\n}\n\n\nclass GameModel extends NodeTraverser {\n\tconstructor(){\n\t\tsuper();\n\t\tthis.realGame = true;\n\t\tthis.boardSize = null;\n\t\tthis.nodes = [];\n\t\tthis.gameInfo = {};\n\n\t\tthis.nodeMap = {};\n\t\tthis.nodesByMoveNumber = [];\n\t\tthis.pointMovesMatrix = [];\n\n\t\tthis.gameEndingNode = null;\n\t}\n\n\n\tstatic newModel(boardSize, handicapPoints) {\n\n\t\tvar gameModel = new GameModel();\n\t\tgameModel.boardSize = boardSize;\n\t\tfor (var x = 0; x < gameModel.boardSize; x++) {\n\t\t\tgameModel.pointMovesMatrix[x] = [];\n\t\t}\n\n\t\tvar firstNode = new Node(null, gameModel);\n\t\tgameModel.indexNode(firstNode);\n\t\tgameModel.nodes[0] = firstNode;\n\t\tgameModel.gameEndingNode = firstNode;\n\n\t\tif (handicapPoints && handicapPoints.length > 0) {\n\t\t\tvar gameInfo = gameModel.gameInfo;\n\t\t\tgameInfo.rule = {};\n\t\t\tgameInfo.rule['HA'] = handicapPoints.length;\n\t\t\tfirstNode.setup = {\n\t\t\t\t'AB' : handicapPoints\n\t\t\t};\n\t\t}\n\n\t\treturn gameModel;\n\t}\n\n\tindexNode(node) {\n\t\tthis.nodeMap[node.id] = node;\n\t\tvar realGame = node.belongingVariation.realGame;\n\t\tif (realGame) {\n\t\t\tvar point = node.move.point;\n\t\t\tif (point) {\n\t\t\t\tvar pointMovesX = this.pointMovesMatrix[point.x];\n\t\t\t\tvar pointMoves = pointMovesX[point.y];\n\t\t\t\tif (pointMoves) {\n\t\t\t\t\tpointMoves.push(node);\n\t\t\t\t} else {\n\t\t\t\t\tpointMoves = [ node ];\n\t\t\t\t\tpointMovesX[point.y] = pointMoves;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.move.color) {\n\t\t\t\tvar mn = node.move.variationMoveNumber;\n\t\t\t\tthis.nodesByMoveNumber[mn] = node;\n\t\t\t}\n\t\t}\n\t}\n\n\tunindexNode(node) {\n\t\tthis.nodeMap[node.id] = null;\n\t\tvar realGame = node.belongingVariation.realGame;\n\t\tif (realGame) {\n\t\t\tvar point = node.move.point;\n\t\t\tif (point) {\n\t\t\t\tvar pointMovesX = this.pointMovesMatrix[point.x];\n\t\t\t\tvar pointMoves = pointMovesX[point.y];\n\t\t\t\tif (pointMoves) {\n\t\t\t\t\tvar index = pointMoves.indexOf(node);\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tpointMoves.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.move.color) {\n\t\t\t\tvar mn = node.move.variationMoveNumber;\n\t\t\t\tthis.nodesByMoveNumber[mn] = null;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\n\nclass Variation extends NodeTraverser {\n\n\tconstructor(baseNode, parentVariation) {\n\t\tsuper();\n\t\tthis.baseNode = baseNode;\n\t\tthis.parentVariation = parentVariation;\n\t\tthis.realGame = false;\n\t\tthis.nodes = [];\n\t\tthis.index = 0;\n\t\tthis.id = 'v' + yogo.nextuid();\n\t}\n\n\tnextVariation() {\n\t\tvar variations = this.baseNode.variations;\n\t\tvar nextVindex = (this.index + 1) % variations.length;\n\t\tif (nextVindex == 0) {\n\t\t\tnextVindex = 1;\n\t\t}\n\t\treturn variations[nextVindex];\n\t}\n\n\tpreviousVariation() {\n\t\tvar variations = this.baseNode.variations;\n\t\tvar nextVindex = (this.index - 1 + variations.length)\n\t\t\t\t% variations.length;\n\t\tif (nextVindex == 0) {\n\t\t\tnextVindex = variations.length - 1;\n\t\t}\n\t\treturn variations[nextVindex];\n\t}\n\n\trealGameBaseNode() {\n\t\tvar variation = this;\n\t\twhile (variation && !variation.realGame) {\n\t\t\tif (variation.parentVariation.realGame) {\n\t\t\t\treturn variation.baseNode;\n\t\t\t}\n\t\t\tvariation = variation.parentVariation;\n\t\t}\n\t}\n}\n\nclass Node {\n\tconstructor(previousNode, belongingVariation) {\n\t\tthis.previousNode = previousNode;\n\t\tthis.belongingVariation = belongingVariation;\n\t\tthis.nextNode = null;\n\t\tthis.props = {};\n\t\tthis.basic = {};\n\t\tthis.move = {};\n\t\tthis.status = {};\n\t\tthis.id = 'n' + yogo.nextuid();\n\t\tthis.position = null;\n\n\t\tif (!previousNode) {\n\t\t\tthis.setMoveNumber();\n\t\t}\n\t}\n\n\tisVariationFirstNode() {\n\t\tvar pn = this.previousNode;\n\t\treturn !pn || pn.belongingVariation !== this.belongingVariation;\n\t}\n\n\tisVariationLastNode() {\n\t\treturn !this.nextNode && !this.variations;\n\t}\n\n\tisGameBegining() {\n\t\tvar pn = this.previousNode;\n\t\tvar v = this.belongingVariation;\n\t\t// !pn && v.realGame && !v.parentVariation\n\t\treturn (!pn && v instanceof GameModel);\n\t}\n\n\tisSetup() {\n\t\treturn !!this.setup;\n\t}\n\n\thasComment() {\n\t\treturn !!(this.basic && this.basic['C']);\n\t}\n\n\thasMarks() {\n\t\treturn !!this.marks;\n\t}\n\n\thasRemark() {\n\t\treturn !!this.remark;\n\t}\n\n\tfindNodeInAncestors(predicate) {\n\t\tvar node = this;\n\t\twhile (true) {\n\t\t\tnode = node.previousNode;\n\t\t\tif (!node) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar result = predicate.call(node, node);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (result === true) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindNodeInMainline(predicate) {\n\t\tvar node = this;\n\t\twhile (true) {\n\t\t\tif (node.nextNode) {\n\t\t\t\tnode = node.nextNode;\n\t\t\t} else if (node.variations) {\n\t\t\t\tnode = node.variations[0].nodes[0];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar result = predicate.call(node, node);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (result === true) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindNodeInSuccessors(predicate) {\n\t\tvar node = this;\n\t\twhile (true) {\n\t\t\tif (node.nextNode) {\n\t\t\t\tnode = node.nextNode;\n\t\t\t} else if (node.variations) {\n\t\t\t\tfor (var vi = 0; vi < node.variations.length; vi++) {\n\t\t\t\t\tvar variation = node.variations[vi];\n\t\t\t\t\tvar foundNode = variation.findNode(predicate);\n\t\t\t\t\tif (foundNode) {\n\t\t\t\t\t\treturn foundNode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar result = predicate.call(node, node);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (result === true) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverseSuccessorNodes(nodeCallback, variationCallback) {\n\t\tvar node = this;\n\t\twhile (true) {\n\t\t\tif (node.nextNode) {\n\t\t\t\tnode = node.nextNode;\n\t\t\t} else if (node.variations) {\n\t\t\t\tfor (var vi = 0; vi < node.variations.length; vi++) {\n\t\t\t\t\tvar variation = node.variations[vi];\n\t\t\t\t\tif (variationCallback) {\n\t\t\t\t\t\tvar vcr = variationCallback.call(variation, variation,\n\t\t\t\t\t\t\t\tnull);\n\t\t\t\t\t\tif (vcr === false) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar goon = variation.traverseNodes(nodeCallback,\n\t\t\t\t\t\t\tvariationCallback);\n\t\t\t\t\tif (goon === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar goon = nodeCallback.call(node, node);\n\t\t\tif (goon === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tnextNodeAt(coor) {\n\t\tvar nextNode = this.nextNode;\n\t\tif (nextNode && nextNode.move.point) {\n\t\t\tvar point = nextNode.move.point;\n\t\t\tif (coor.x === point.x && coor.y === point.y) {\n\t\t\t\treturn nextNode;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (this.branchPoints) {\n\t\t\tfor (var i = 0; i < this.branchPoints.length; i++) {\n\t\t\t\tvar point = this.branchPoints[i];\n\t\t\t\tif (coor.x === point.x && coor.y === point.y) {\n\t\t\t\t\tvar variation = this.variations[i];\n\t\t\t\t\treturn variation.nodes[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tnextPass(color) {\n\t\tvar nextNode = this.nextNode;\n\t\tif (nextNode && nextNode.status.pass) {\n\t\t\tif (nextNode.move.color == color) {\n\t\t\t\treturn nextNode;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (this.variations) {\n\t\t\tfor (var i = 0; i < this.variations.length; i++) {\n\t\t\t\tvar variation = this.variations[i];\n\t\t\t\tvar node0 = variation.nodes[0];\n\t\t\t\tif (node0.status.pass && node0.move.color == color) {\n\t\t\t\t\treturn node0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tnextMoveColor() {\n\t\tvar color;\n\t\tif (this.move['PL']) {\n\t\t\tcolor = this.move['PL'];\n\t\t} else if (this.move.color) {\n\t\t\tcolor = (this.move.color === 'B') ? 'W' : 'B';\n\t\t} else if (this.isGameBegining()) {\n\t\t\tvar v = this.belongingVariation;\n\t\t\t// v is GameModel\n\t\t\tif (v.gameInfo.rule && v.gameInfo.rule['HA']) {\n\t\t\t\tcolor = 'W';\n\t\t\t}\n\t\t}\n\t\tif (!color) {\n\t\t\tcolor = 'B';\n\t\t}\n\t\treturn color;\n\t}\n\n\tsetMoveNumber() {\n\t\tvar playOrPass = this.status.move || this.status.pass;\n\t\tvar mns;\n\t\tif (this.previousNode) {\n\t\t\tvar lastMove = this.previousNode.move;\n\t\t\tmns = [ lastMove.displayMoveNumber + (playOrPass ? 1 : 0),\n\t\t\t\t\tlastMove.variationMoveNumber + (playOrPass ? 1 : 0) ];\n\t\t} else {\n\t\t\tmns = playOrPass ? [ 1, 1 ] : [ 0, 0 ];\n\t\t}\n\n\t\tthis.move.displayMoveNumber = mns[0];\n\t\tthis.move.variationMoveNumber = mns[1];\n\n\t\tvar thisVariation = this.belongingVariation;\n\t\tvar realGame = thisVariation.realGame;\n\t\tif (this.isVariationFirstNode() && !realGame && thisVariation.index > 0) {\n\t\t\tthis.move.displayMoveNumber = playOrPass ? 1 : 0;\n\t\t\tthis.move.variationMoveNumber = playOrPass ? 1 : 0;\n\t\t}\n\n\t\tif (this.move['MN']) {\n\t\t\tthis.move.displayMoveNumber = this.move['MN'];\n\t\t}\n\t}\n\n\tresetMoveNumber() {\n\t\tthis.setMoveNumber();\n\t\tvar thisVariation = this.belongingVariation;\n\t\tvar vcb = function(variation) {\n\t\t\tif (variation !== thisVariation && variation.index > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tvar ncb = function(node) {\n\t\t\tnode.setMoveNumber();\n\t\t};\n\t\tthis.traverseSuccessorNodes(ncb, vcb);\n\t}\n\n\tsetBranchPoints() {\n\t\tif (!this.variations) {\n\t\t\treturn;\n\t\t}\n\t\tvar variations = this.variations;\n\t\tvar branchPoints = [];\n\t\tfor (var i = 0; i < variations.length; i++) {\n\t\t\tvar variation = variations[i];\n\t\t\tvariation.index = i;\n\t\t\tvar node0 = variation.nodes[0];\n\t\t\tif (node0.status.move) {\n\t\t\t\tvar coordinate = node0.move.point;\n\t\t\t\tbranchPoints.push(coordinate);\n\t\t\t} else {\n\t\t\t\tbranchPoints.push({\n\t\t\t\t\tx : 52,\n\t\t\t\t\ty : 52\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tthis.branchPoints = branchPoints;\n\t}\n\n\tdiffPosition(fromNode) {\n\t\tvar fromPosition = fromNode.position;\n\t\tvar toPosition = this.position;\n\t\tvar stonesToRemove = [];\n\t\tvar stonesToAddW = [];\n\t\tvar stonesToAddB = [];\n\t\tvar boardSize = fromPosition.length;\n\t\tfor (var x = 0; x < boardSize; x++) {\n\t\t\tvar fx = fromPosition[x];\n\t\t\tvar tx = toPosition[x];\n\t\t\tif (fx === tx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (var y = 0; y < boardSize; y++) {\n\t\t\t\tvar fromStatus = fx[y];\n\t\t\t\tvar toStatus = tx[y];\n\t\t\t\tif (fromStatus === toStatus || (!fromStatus && !toStatus)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar toRemove = false, toAdd = false;\n\t\t\t\tif (!toStatus) {\n\t\t\t\t\ttoRemove = true;\n\t\t\t\t} else if (!fromStatus) {\n\t\t\t\t\ttoAdd = true;\n\t\t\t\t} else if (fromStatus.color != toStatus.color) {\n\t\t\t\t\ttoRemove = true;\n\t\t\t\t\ttoAdd = true;\n\t\t\t\t}\n\t\t\t\tvar point = {\n\t\t\t\t\tx : x,\n\t\t\t\t\ty : y\n\t\t\t\t};\n\t\t\t\tif (toRemove) {\n\t\t\t\t\tstonesToRemove.push(point);\n\t\t\t\t}\n\t\t\t\tif (toAdd) {\n\t\t\t\t\tif (toStatus.color == 'B') {\n\t\t\t\t\t\tstonesToAddB.push(point);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstonesToAddW.push(point);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tstonesToRemove : stonesToRemove,\n\t\t\tstonesToAddB : stonesToAddB,\n\t\t\tstonesToAddW : stonesToAddW\n\t\t};\n\t}\n}\n\nmodule.exports={GameModel,Variation,Node};\n\n},{\"../util\":3}],2:[function(require,module,exports){\nvar {GameModel,Variation,Node}=require(\"./model\");\nvar yogo=require(\"../util\");\n\nclass SgfParser {\n\n\tconstructor() {\n\n\t\tlet gameInfoGroupToNames = {\n\t\t\troot : 'GM FF AP SZ CA ST',\n\t\t\tbasic : 'GN EV RO DT PC RE GC',\n\t\t\trule : 'HA KM RU TM OT',\n\t\t\tblackPlayer : 'PB BR BS BT',\n\t\t\twhitePlayer : 'PW WR WS WT',\n\t\t\trecorder : 'US SO AP',\n\t\t\tmisc : 'CP ON AN'\n\t\t};\n\n\t\tlet nodeGroupToPropNames = {\n\t\t\tbasic : 'N C',\n\t\t\tsetup : 'AB AW AE',\n\t\t\tmove : 'B W BL WL PL MN OB OW KO FG V',\n\t\t\tremark : 'GB GW UC DM TE BM DO IT HO',\n\t\t\tmarks : 'LB TR CR SQ MA SL TW TB AR LN',\n\t\t\tinheritProps : 'PM DD DW'\n\t\t};\n\n\t\tlet typeToPropNames = {\n\t\t\tinteger : 'MN OB OW PM SZ HA ST',\n\t\t\t'float' : 'V KM',\n\t\t\tbool : 'DO IT KO',\n\t\t\ttriple : 'GB GW UC DM TE BM HO',\n\t\t\tpoint : 'B W',\n\t\t\tlableList : 'LB',\n\t\t\tpointList : 'AB AW AE TR CR SQ MA SL AR LN TW TB DD VM',\n\t\t\tstringArray : ''\n\t\t};\n\n\t\tfunction reverseMap(map) {\n\t\t\tvar reversed = {};\n\t\t\tfor (let groupName in map) {\n\t\t\t\tlet names = map[groupName].split(' ');\n\t\t\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\t\t\treversed[names[i]] = groupName;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reversed;\n\t\t}\n\n\t\tthis.gameInfoPropNameToGroup = reverseMap(gameInfoGroupToNames);\n\t\tthis.nodePropNameToGroup = reverseMap(nodeGroupToPropNames);\n\t\tthis.propNameToType = reverseMap(typeToPropNames);\n\t}\n\n\n\tparseSgf(sgfText) {\n\t\t// P=()[];\\\n\t\t// /[P]|[^P]*/g\n\t\tvar tokenPatt = /[()\\[\\];\\\\]|[^()\\[\\];\\\\]*/g;\n\n\t\tvar gameCollection = [];\n\t\tvar tokenState = null;// inProp,inPropValue\n\n\t\tvar curGameModel;\n\t\tvar curVariation;\n\t\tvar curNode;\n\t\tvar curPropName;\n\t\tvar curPropValues;\n\t\tvar curVariationDepth = 0;\n\n\t\tvar tokens = sgfText.match(tokenPatt);\n\t\tvar tokenBuffer = '';\n\n\t\tfunction finishPropertyIfAny() {\n\t\t\tif (curPropName) {\n\t\t\t\tcurNode.props[curPropName] = curPropValues;\n\t\t\t\tcurPropName = null;\n\t\t\t\tcurPropValues = null;\n\t\t\t}\n\t\t}\n\n\t\tfor (var tokenIndex = 0; tokenIndex < tokens.length; tokenIndex++) {\n\t\t\tvar token = tokens[tokenIndex];\n\n\t\t\tif (token == '\\\\') {\n\t\t\t\tif (tokenState == 'inPropValue') {\n\t\t\t\t\ttoken = tokens[++tokenIndex];\n\t\t\t\t\tif (token.startsWith('\\n')) {\n\t\t\t\t\t\ttoken = token.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\ttokenBuffer += token;\n\t\t\t\t} else {\n\t\t\t\t\tyogo.logError('unexpected token: \\\\', 'parse sgf');\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tokenState == 'inPropValue') {\n\t\t\t\tif (token != ']') {\n\t\t\t\t\ttokenBuffer += token;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token == '(') {\n\t\t\t\tif (curVariationDepth == 0) {\n\t\t\t\t\tcurGameModel = new GameModel();\n\t\t\t\t\tgameCollection.push(curGameModel);\n\t\t\t\t\tcurVariation = curGameModel;\n\t\t\t\t} else {\n\t\t\t\t\tfinishPropertyIfAny();\n\t\t\t\t\tvar parentVariation = curVariation;\n\t\t\t\t\tcurVariation = new Variation(curNode, parentVariation);\n\t\t\t\t\tvar realGame = parentVariation.realGame\n\t\t\t\t\t\t\t&& !curNode.variations;\n\t\t\t\t\tif (realGame) {\n\t\t\t\t\t\tcurVariation.realGame = true;\n\t\t\t\t\t\tcurNode.variations = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurVariation.realGame = false;\n\t\t\t\t\t\tif (!curNode.variations) {\n\t\t\t\t\t\t\tcurNode.variations = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcurVariation.index = curNode.variations.length;\n\t\t\t\t\tcurNode.variations.push(curVariation);\n\t\t\t\t}\n\t\t\t\ttokenBuffer = '';\n\t\t\t\ttokenState = null;\n\t\t\t\tcurVariation.variationDepth = curVariationDepth;\n\t\t\t\tcurVariationDepth++;\n\t\t\t} else if (token == ')') {\n\t\t\t\tfinishPropertyIfAny();\n\t\t\t\ttokenBuffer = '';\n\t\t\t\tcurVariationDepth--;\n\t\t\t\tif (curVariationDepth < 0) {\n\t\t\t\t\tyogo.logError('dismatch parenthesis: )', 'parse sgf')\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcurNode = curVariation.baseNode;\n\t\t\t\tif (curVariation.nodes.length == 0) {\n\t\t\t\t\tyogo.logWarn('empty variation!', 'parse sgf')\n\t\t\t\t\tcurNode.variations.pop();\n\t\t\t\t}\n\t\t\t\tcurVariation = curVariation.parentVariation;\n\t\t\t\ttokenState = null;\n\t\t\t} else if (token == ';') {\n\t\t\t\tfinishPropertyIfAny();\n\t\t\t\ttokenBuffer = '';\n\t\t\t\tvar previousNode = curNode;\n\t\t\t\tcurNode = new Node(previousNode, curVariation);\n\t\t\t\tif (previousNode\n\t\t\t\t\t\t&& previousNode.belongingVariation === curVariation) {\n\t\t\t\t\tpreviousNode.nextNode = curNode;\n\t\t\t\t}\n\t\t\t\tcurVariation.nodes.push(curNode);\n\t\t\t\ttokenState = 'inProp';\n\t\t\t} else if (token == '[') {\n\t\t\t\ttokenState = 'inPropValue';\n\t\t\t} else if (token == ']') {\n\t\t\t\tif (curPropName != 'C') {\n\t\t\t\t\ttokenBuffer = tokenBuffer.trim();\n\t\t\t\t}\n\t\t\t\tif (!curPropValues) {\n\t\t\t\t\tcurPropValues = tokenBuffer\n\t\t\t\t} else if (curPropValues instanceof Array) {\n\t\t\t\t\tcurPropValues.push(tokenBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tcurPropValues = [ curPropValues, tokenBuffer ];\n\t\t\t\t}\n\t\t\t\ttokenBuffer = '';\n\t\t\t\ttokenState = 'inProp';\n\t\t\t} else {\n\t\t\t\tif (tokenState == 'inProp') {\n\t\t\t\t\ttokenBuffer += token;\n\t\t\t\t\ttokenBuffer = tokenBuffer.trim();\n\t\t\t\t\tif (tokenBuffer == '') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (/[a-zA-Z0-9]+/.test(tokenBuffer)) {\n\t\t\t\t\t\tfinishPropertyIfAny();\n\t\t\t\t\t\tcurPropName = tokenBuffer;\n\t\t\t\t\t\ttokenBuffer = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyogo.logError('unexpected property name: '\n\t\t\t\t\t\t\t\t+ tokenBuffer, 'parse sgf')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokenBuffer += token;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gameCollection;\n\t}\n\n\tbuildGoGameModel(gameCollection) {\n\n\t\tfor (var gtIndex = 0; gtIndex < gameCollection.length; gtIndex++) {\n\t\t\tvar gameModel = gameCollection[gtIndex];\n\t\t\tthis.processGameInfo(gameModel);\n\n\t\t\tfor (var x = 0; x < gameModel.boardSize; x++) {\n\t\t\t\tgameModel.pointMovesMatrix[x] = [];\n\t\t\t}\n\n\t\t\tvar parser = this;\n\n\t\t\tvar nodeCallback = function(node) {\n\n\t\t\t\tvar props = node.props;\n\t\t\t\tfor (let name in props) {\n\t\t\t\t\tvar group = parser.nodePropNameToGroup[name];\n\t\t\t\t\tif (!group) {\n\t\t\t\t\t\tif (parser.gameInfoPropNameToGroup[name]) {\n\t\t\t\t\t\t\tif (node.previousNode) {\n\t\t\t\t\t\t\t\tyogo.logWarn(\n\t\t\t\t\t\t\t\t\t\t'game info not at the first node: '\n\t\t\t\t\t\t\t\t\t\t\t\t+ name, 'node');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tyogo.logWarn('unknown property name: ' + name,\n\t\t\t\t\t\t\t\t\t'node');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar propValue = props[name];\n\t\t\t\t\tvar type = parser.propNameToType[name];\n\t\t\t\t\tpropValue = parser.propertyTypeConvert(propValue, type,\n\t\t\t\t\t\t\tgameModel.boardSize);\n\n\t\t\t\t\tif (!node[group]) {\n\t\t\t\t\t\tnode[group] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode[group][name] = propValue;\n\t\t\t\t}\n\n\t\t\t\tif (node.move['W'] && node.move['B']) {\n\t\t\t\t\tyogo.logWarn('both Black and White move in one node: B['\n\t\t\t\t\t\t\t+ node.props['B'] + '],W[' + node.props['W'] + ']',\n\t\t\t\t\t\t\t'node');\n\t\t\t\t}\n\n\t\t\t\tnode.status.move = !!(node.move['W'] || node.move['B']);\n\t\t\t\tnode.status.pass = node.move['W'] === null\n\t\t\t\t\t\t|| node.move === null;\n\n\t\t\t\tif (node.status.move) {\n\t\t\t\t\tvar point = (node.move['W'] || node.move['B']);\n\t\t\t\t\tnode.move.point = point;\n\t\t\t\t\tnode.move.color = (node.move['B']) ? 'B' : 'W';\n\t\t\t\t}else if(node.status.pass){\n\t\t\t\t\tnode.move.color = (node.move['B'] === null) ? 'B' : 'W';\n\t\t\t\t}\n\n\t\t\t\tif (node.isVariationLastNode()) {\n\t\t\t\t\tvar realGame = node.belongingVariation.realGame;\n\t\t\t\t\tif (realGame) {\n\t\t\t\t\t\tgameModel.gameEndingNode = node;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tgameModel.traverseNodes(nodeCallback);\n\n\t\t\tvar nodeCallback2 = function(node) {\n\n\t\t\t\tnode.setMoveNumber();\n\n\t\t\t\tnode.setBranchPoints();\n\n\t\t\t\tgameModel.indexNode(node);\n\t\t\t};\n\n\t\t\tgameModel.traverseNodes(nodeCallback2);\n\t\t}\n\t}\n\n\tprocessGameInfo(gameModel) {\n\n\t\tif (!gameModel.gameInfo) {\n\t\t\tgameModel.gameInfo = {};\n\t\t}\n\t\tvar gameInfo = gameModel.gameInfo;\n\n\t\tvar gameInfoNode = gameModel.nodes[0];\n\t\tvar props = gameInfoNode.props;\n\t\tif (props['GM'] && props['GM'] !== '1') {\n\t\t\tyogo.logError('unsupported game type: GM=' + props['GM'],\n\t\t\t\t\t'game info');\n\t\t}\n\t\tif (!props['SZ']) {\n\t\t\tyogo.logError('missing board size(SZ)', 'game info');\n\t\t}\n\n\t\tfor (let name in props) {\n\t\t\tvar group = this.gameInfoPropNameToGroup[name];\n\t\t\tif (!group) {\n\t\t\t\tif (!(this.nodePropNameToGroup && this.nodePropNameToGroup[name])) {\n\t\t\t\t\tyogo.logWarn('unknown property name: ' + name, 'game info');\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!gameInfo[group])\n\t\t\t\tgameInfo[group] = {};\n\t\t\tvar value = props[name];\n\t\t\tif (this.propNameToType[name]) {\n\t\t\t\tvalue = this.propertyTypeConvert(value,\n\t\t\t\t\t\tthis.propNameToType[name], gameModel.boardSize);\n\t\t\t}\n\t\t\tgameInfo[group][name] = value;\n\t\t}\n\n\t\tfunction changePropName(obj, names) {\n\t\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\t\tvar name = names[i];\n\t\t\t\tvar oriName = name[0], newName = name[1];\n\t\t\t\tobj[newName] = obj[oriName];\n\t\t\t\tdelete obj[oriName];\n\t\t\t}\n\t\t}\n\n\t\tif (gameInfo.blackPlayer) {\n\t\t\tchangePropName(gameInfo.blackPlayer, [ [ 'PB', 'name' ],\n\t\t\t\t\t[ 'BR', 'rank' ], [ 'BS', 'species' ], [ 'BT', 'term' ] ]);\n\t\t}\n\t\tif (gameInfo.whitePlayer) {\n\t\t\tchangePropName(gameInfo.whitePlayer, [ [ 'PW', 'name' ],\n\t\t\t\t\t[ 'WR', 'rank' ], [ 'WS', 'species' ], [ 'WT', 'term' ] ]);\n\t\t}\n\n\t\tvar boardSize = gameInfo.root['SZ'];\n\t\tif (isNaN(boardSize) || boardSize < 5 || boardSize > 51) {\n\t\t\tyogo.logError('wrong board size(SZ)', 'game info');\n\t\t}\n\n\t\tgameModel.boardSize = boardSize;\n\t}\n\n\tparseCoordinate(sgfPoint, boardSize) {\n\t\tif (!sgfPoint.match(/^[a-z][a-z]$/i)) {\n\t\t\tyogo.logWarn('wrong coordinate: ' + sgfPoint, 'node');\n\t\t\treturn null;\n\t\t}\n\t\tvar x = sgfPoint.charCodeAt(0);\n\t\tvar y = sgfPoint.charCodeAt(1);\n\t\tif (x < 97) {\n\t\t\tx = 26 + x - 65;\n\t\t} else {\n\t\t\tx -= 97;\n\t\t}\n\t\tif (y < 97) {\n\t\t\ty = 26 + y - 65;\n\t\t} else {\n\t\t\ty -= 97;\n\t\t}\n\t\tif (x >= boardSize || y >= boardSize) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tx : x,\n\t\t\ty : y\n\t\t};\n\t}\n\n\tpropertyTypeConvert(propValue, type, boardSize) {\n\n\t\tvar oriValue = propValue;\n\t\tif (type) {\n\t\t\tif ([ 'lableList', 'pointList', 'stringArray' ].indexOf(type) >= 0) {\n\t\t\t\tif (!(propValue instanceof Array)) {\n\t\t\t\t\tpropValue = [ propValue ];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (propValue instanceof Array) {\n\t\t\t\t\tpropValue = propValue[0] || '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type == 'point') {\n\t\t\t\tif (propValue == '') {\n\t\t\t\t\tpropValue = null;\n\t\t\t\t} else {\n\t\t\t\t\tpropValue = this.parseCoordinate(propValue, boardSize);\n\t\t\t\t}\n\t\t\t} else if (type == 'lableList') {\n\t\t\t\tvar coordinates = [];\n\t\t\t\tfor (var pi = 0; pi < propValue.length; pi++) {\n\t\t\t\t\tvar coorStrAndLabel = propValue[pi].split(':');\n\t\t\t\t\tvar coorStr = coorStrAndLabel[0];\n\t\t\t\t\tvar label = coorStrAndLabel[1];\n\t\t\t\t\tif (!label)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar coor = this.parseCoordinate(coorStr, boardSize);\n\t\t\t\t\tif (coor != null) {\n\t\t\t\t\t\tcoor.label = label;\n\t\t\t\t\t\tcoordinates.push(coor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpropValue = coordinates.length > 0 ? coordinates : null;\n\t\t\t} else if (type == 'pointList') {\n\t\t\t\tvar coordinates = [];\n\t\t\t\tfor (var pi = 0; pi < propValue.length; pi++) {\n\t\t\t\t\tvar coorStr = propValue[pi];\n\t\t\t\t\tif (coorStr.indexOf(':') > 0) {\n\t\t\t\t\t\tvar coorStrPair = coorStr.split(':');\n\t\t\t\t\t\tvar coorFrom = this.parseCoordinate(coorStrPair[0],\n\t\t\t\t\t\t\t\tboardSize);\n\t\t\t\t\t\tvar coorTo = this.parseCoordinate(coorStrPair[1],\n\t\t\t\t\t\t\t\tboardSize);\n\t\t\t\t\t\tif (coorFrom && coorTo) {\n\t\t\t\t\t\t\tvar coorRange = {\n\t\t\t\t\t\t\t\tcoorFrom : coorFrom,\n\t\t\t\t\t\t\t\tcoorTo : coorTo\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcoordinates.push(coorRange);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar coor = this.parseCoordinate(coorStr, boardSize);\n\t\t\t\t\t\tif (coor != null) {\n\t\t\t\t\t\t\tcoordinates.push(coor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpropValue = coordinates.length > 0 ? coordinates : null;\n\t\t\t} else if (type == 'triple') {\n\t\t\t\tpropValue = (propValue == '2') ? 2 : 1;\n\t\t\t} else if (type == 'bool') {\n\t\t\t\tpropValue = true;\n\t\t\t} else if (type == 'integer') {\n\t\t\t\tpropValue = parseInt(propValue);\n\t\t\t\tif (isNaN(propValue)) {\n\t\t\t\t\tyogo.logWarn(\"can't parse to Integer: \" + name + ','\n\t\t\t\t\t\t\t+ oriValue, 'node');\n\t\t\t\t}\n\t\t\t} else if (type == 'float') {\n\t\t\t\tpropValue = parseFloat(propValue);\n\t\t\t\tif (isNaN(propValue)) {\n\t\t\t\t\tyogo.logWarn(\"can't parse to Float: \" + name + ','\n\t\t\t\t\t\t\t+ oriValue, 'node');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyogo.logWarn('to do: ' + name, 'node');\n\t\t\t}\n\t\t}\n\n\t\treturn propValue;\n\t}\n\n\n\tstatic parse(sgfText) {\n\t\tvar sgfParser = new SgfParser();\n\t\tvar gameCollection = sgfParser.parseSgf(sgfText);\n\t\tsgfParser.buildGoGameModel(gameCollection);\n\t\treturn gameCollection;\n\t}\n\n\n\tstatic parseGameModel0(sgfText) {\n\t\tlet gameCollection=SgfParser.parse(sgfText);\n\t\treturn gameCollection[0];\n\t}\n}\n\n\nmodule.exports=SgfParser\n},{\"../util\":3,\"./model\":1}],3:[function(require,module,exports){\nvar yogo = {\n\t_uid : 1024,\n\tnextuid : function() {\n\t\tyogo._uid++;\n\t\treturn yogo._uid;\n\t},\n\n\tlog : function(msg, category, level) {\n\t\tvar func = console[level];\n\t\tif (!func)\n\t\t\tfunc = console['log'];\n\t\tif (func instanceof Function) {\n\t\t\tif (!category)\n\t\t\t\tcategory = 'yogo';\n\t\t\ttry {\n\t\t\t\tfunc.call(console, category + ':', msg);\n\t\t\t} catch (e) {\n\t\t\t}\n\t\t}\n\t},\n\n\tlogInfo : function(msg, category) {\n\t\tyogo.log(msg, category, 'info');\n\t},\n\n\tlogWarn : function(msg, category) {\n\t\tyogo.log(msg, category, 'warn');\n\t},\n\n\tlogError : function(msg, category) {\n\t\tyogo.log(msg, category, 'error');\n\t},\n\n\texportFunctions : function(obj, funcNames) {\n\t\tfor (var i = 0; i < funcNames.length; i++) {\n\t\t\tvar funcName = funcNames[i];\n\t\t\tvar func = obj[funcName];\n\t\t\tif (typeof (func) !== 'function') {\n\t\t\t\tyogo.logWarn(funcName + ' is not a function');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis[funcName] = func.bind(obj);\n\t\t}\n\t},\n\n\tevaluatePointRange : function(coorFrom, coorTo) {\n\t\tvar rangePoints = [];\n\t\tvar fromX = coorFrom.x, toX = coorTo.x;\n\t\tvar fromY = coorFrom.y, toY = coorTo.y;\n\t\tfor (var x = fromX; x <= toX; x++) {\n\t\t\tfor (var y = fromY; y <= toY; y++) {\n\t\t\t\trangePoints.push({\n\t\t\t\t\tx : x,\n\t\t\t\t\ty : y\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn rangePoints;\n\t},\n\n\tfindPoint : function(coorArray, coor) {\n\t\tfor (var i = 0; i < coorArray.length; i++) {\n\t\t\tvar c = coorArray[i];\n\t\t\tif (c.x === coor.x && c.y === coor.y) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tremovePoint : function(coorArray, coor) {\n\t\tif (!coorArray) {\n\t\t\treturn false;\n\t\t}\n\t\tvar index = yogo.findPoint(coorArray, coor);\n\t\tif (index >= 0) {\n\t\t\tcoorArray.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n};\n\nmodule.exports=yogo;\n\n},{}]},{},[2]);\n"],"file":"yogo.min.js"}